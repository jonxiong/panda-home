# HTTP缓存

- [HTTP缓存](#http缓存)
  - [背景](#背景)
  - [http缓存机制](#http缓存机制)
    - [强制缓存](#强制缓存)
      - [Expires](#expires)
      - [Cache-Control](#cache-control)
    - [协商缓存](#协商缓存)
      - [Last-Modified](#last-modified)
      - [if-Modified-Since](#if-modified-since)
      - [Etag](#etag)
      - [If-None-Match](#if-none-match)
    - [缓存的优点](#缓存的优点)
    - [不同刷新的请求执行过程](#不同刷新的请求执行过程)
  - [浏览器缓存技术](#浏览器缓存技术)
  - [keep alive](#keep-alive)

## 背景

HTTP的缓存属于客户端缓存，后面会提到为什么属于客户端缓存。所以我们认为浏览器存在一个缓存数据库，用于储存一些不经常变化的静态文件（图片、css、js等）。我们将缓存分为强制缓存和协商缓存

> 目标都是一致的，就是尽快返回请求数据、减少延迟
> 浏览器保存的文件就被称为缓存（不是指Cookie或者Localstorage）

## http缓存机制

### 强制缓存

> 当缓存数据库中已有所请求的数据时。客户端直接从缓存数据库中获取数据。当缓存数据库中没有所请求的数据时，客户端的才会从服务端获取数据

![2020-06-12-01](https://user-gold-cdn.xitu.io/2017/11/29/16007be6f64ff7f7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

#### Expires

Exprires的值为服务端返回的数据到期时间。当再次请求时的请求时间小于返回的此时间，则直接使用缓存数据。但由于服务端时间和客户端时间可能有误差，这也将导致缓存命中的误差，另一方面，Expires是HTTP1. 0的产物，故现在大多数使用Cache-Control替代

#### Cache-Control

Cache-Control有很多属性，不同的属性代表的意义也不同

* private：客户端可以缓存
* public：客户端和代理服务器都可以缓存
* max-age=t：缓存内容将在t秒后失效
* no-cache：需要使用协商缓存来验证缓存数据
* no-store：所有内容都不会缓存

### 协商缓存

> 又称对比缓存，客户端会先从缓存数据库中获取到一个缓存数据的标识，得到标识后请求服务端验证是否失效（新鲜），如果没有失效服务端会返回304，此时客户端直接从缓存中获取所请求的数据，如果标识失效，服务端会返回更新后的数据

![2020-06-12](https://user-gold-cdn.xitu.io/2017/11/29/16007d1c835d5461?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

#### Last-Modified

> 服务器在响应请求时，会告诉浏览器资源的最后修改时间

#### if-Modified-Since

> 浏览器再次请求服务器的时候，请求头会包含此字段，后面跟着在缓存中获得的最后修改时间。服务端收到此请求头发现有if-Modified-Since，则与被请求资源的最后修改时间进行对比，如果一致则返回304和响应报文头，浏览器只需要从缓存中获取信息即可。

从字面上看，就是说：从某个时间节点算起，是否文件被修改了

* 如果真的被修改：那么开始传输响应一个整体，服务器返回：200 OK
* 如果没有被修改：那么只需传输响应header，服务器返回：304 Not Modified

#### Etag

> 服务器响应请求时，通过此字段告诉浏览器当前资源在服务器生成的唯一标识（生成规则由服务器决定）

#### If-None-Match

> 再次请求服务器时，浏览器的请求报文头部会包含此字段，后面的值为在缓存中获取的标识。服务器接收到次报文后发现If-None-Match则与被请求资源的唯一标识进行对比。

* 不同，说明资源被改动过，则响应整个资源内容，返回状态码200。
* 相同，说明资源无心修改，则响应header，浏览器直接从缓存中获取数据信息。返回状态码304. 

注意：但是实际应用中由于Etag的计算是使用算法来得出的，而算法会占用服务端计算的资源，所有服务端的资源都是宝贵的，所以就很少使用Etag了
注意：两类缓存机制可以同时存在，强制缓存的优先级高于协商缓存，当执行强制缓存时，如若缓存命中，则直接使用缓存数据库数据，不在进行缓存协商。

### 缓存的优点

* 减少了冗余的数据传递，节省宽带流量
* 减少了服务器的负担，大大提高了网站性能
* 加快了客户端加载网页的速度 这也正是HTTP缓存属于客户端缓存的原因。

### 不同刷新的请求执行过程

* 浏览器地址栏中写入URL，回车，浏览器发现缓存中有这个文件了，不用继续请求了，直接去缓存拿。（最快）
* F5就是告诉浏览器，别偷懒，好歹去服务器看看这个文件是否有过期了。于是浏览器就胆胆襟襟的发送一个请求带上If-Modify-since。
* Ctrl+F5 告诉浏览器，你先把你缓存中的这个文件给我删了，然后再去服务器请求个完整的资源文件下来。于是客户端就完成了强行更新的操作. 

## [浏览器缓存技术](https://juejin.im/post/5b9346dcf265da0aac6fbe57#heading-3)

**from dis cache** 或者 **from memory cache**: 该资源直接从本地硬盘或者浏览器内存读取，而并没有请求服务器
浏览器是否使用缓存、缓存多久，是由服务器控制的。<br>
准确来说，当浏览器请求一个网页（或者其他资源）时，服务器发回的响应的「响应头」部分的某些字段指明了有关缓存的关键信息。

浏览器缓存机制: 强缓存和协商缓存

* 1）浏览器在加载资源时，先根据这个资源的一些http header判断它是否命中强缓存，强缓存如果命中，浏览器直接从自己的缓存中读取资源，不会发请求到服务器。比如：某个css文件，如果浏览器在加载它所在的网页时，这个css文件的缓存配置命中了强缓存，浏览器就直接从缓存中加载这个css，连请求都不会发送到网页所在服务器；
* 2）当强缓存没有命中的时候，浏览器一定会发送一个请求到服务器，通过服务器端依据资源的另外一些http header验证这个资源是否命中协商缓存，如果协商缓存命中，服务器会将这个请求返回，但是不会返回这个资源的数据，而是告诉客户端可以直接从缓存中加载这个资源，于是浏览器就又会从自己的缓存中去加载这个资源；
* 3）强缓存与协商缓存的共同点是：如果命中，都是从客户端缓存中加载资源，而不是从服务器加载资源数据；区别是：强缓存不发请求到服务器，协商缓存会发请求到服务器。
* 4）当协商缓存也没有命中的时候，浏览器直接从服务器加载资源数据。

## keep alive

> 在 HTTP 1. 0 时期，每个 TCP 连接只会被一个 HTTP Transaction（请求加响应）使用。之后，这个 TCP 连接便会被关闭。当网页内容越来越复杂，包含大量图片、CSS 等资源之后，这种模式效率就显得太低了。所以，在 HTTP 1. 1 中，引入了 HTTP persistent connection 的概念，也称为 HTTP keep-alive（后面统一称呼为 HTTP 长连接）

![2-0-2](https://upload-images.jianshu.io/upload_images/3108769-e429124b24c3f80e.png?imageMogr2/auto-orient/strip|imageView2/2/w/450/format/webp)

[跟http缓存相关的header](https://juejin.im/post/5b3c87386fb9a04f9a5cb037)
[参考文章](https://juejin.im/post/5b9346dcf265da0aac6fbe57#heading-3)
[网络HTTP](https://juejin.im/post/5872309261ff4b005c4580d4)