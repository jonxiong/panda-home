# 前端性能优化-加载

- [前端性能优化-加载](#前端性能优化-加载)
  - [首屏加载](#首屏加载)
    - [白屏的定义](#白屏的定义)
    - [白屏性能优化](#白屏性能优化)
      - [loading提示](#loading提示)
      - [（伪)服务器渲染](#伪服务器渲染)
      - [http2](#http2)
      - [开启浏览器缓存](#开启浏览器缓存)
  - [FMP(首次有意义绘制)](#fmp首次有意义绘制)
    - [骨架屏](#骨架屏)
  - [TTI(可交互时间)](#tti可交互时间)
      - [路由级别拆解代码](#路由级别拆解代码)
  - [组件加载](#组件加载)

## 首屏加载

> 首屏加载是被讨论最多的话题, 一方面web 前端首屏的加载性能的确普遍较差, 另一方面, 首屏的加载速度至关重要, 很多时候过长的白屏会导致用户还没有体验到网站功能的时候就流失了, 首屏速度是用户留存的关键点

### 白屏的定义

> 从路由改变起(即用户再按下回车的瞬间)到首次内容绘制(即能看到第一个内容

* 白屏时间 = firstPaint - performance. timing. navigationStart

白屏加载的问题分析: 

* webpack打包出的chunk过大
* 浏览器通常有并发请求控制，Chrome的并发请求就是6个

### 白屏性能优化

#### loading提示
直接在业务中写或者可通过html-webpack-plugin。在其中配置可以插入loading图

``` js
new HtmlWebpackPlugin({
    template: './src/index.html',
    loading: loading // 事先设计好的loading图
})
```

#### （伪)服务器渲染

ssr：参考相关ssr知识

* react: Nuxt. js
* vue: Vue. ssr

#### http2

#### 开启浏览器缓存
可参考http缓存相关知识点

第三方库拆包：
webpack4. x 中：SplitChunksPlugin

## FMP(首次有意义绘制)

> 那么在FCP 和 FMP 之间虽然开始绘制页面, 但是整个页面是没有意义的, 用户依然在焦虑等待, 而且这个时候可能出现乱序的元素或者闪烁的元素, 很影响体验, 此时我们可能需要进行用户体验上的一些优化

### 骨架屏

> 它的意义在于事先撑开即将渲染的元素, 避免闪屏, 同时提示用户这要渲染东西了, 减少用户焦虑

* React: antd 内置的骨架图Skeleton方案
* Vue: vue-skeleton-webpack-plugin

## TTI(可交互时间)

> 当有意义的内容渲染出来之后, 用户会尝试与页面交互, 这个时候页面并不是加载完毕了, 而是看起来页面加载完毕了, 事实上这个时候 JavaScript 脚本依然在密集得执行
> TTI 一般没有特别精确的测量方法, 普遍认为满足**FMP && DOMContentLoader事件触发 && 页面视觉加载85%**这几个条件后, TTI 就算是到来了

* JS脚本体积
  + SplitChunksPlugin拆库的方法减小体积
  + Tree Shaking: 通过程序流分析找出你代码中无用的代码并剔除, 依赖es6的module模块的静态特性, 通过分析剔除无用代码
* JS本身执行速度

#### 路由级别拆解代码

> 我们在上文中已经通过SplitChunksPlugin将第三方库进行了抽离, 但是在首屏加载过程中依然有很多冗余代码, 比如我们的首页是个登录界面, 那么其实用到的代码很简单
> 需要我们进行对代码在路由级别的拆分, 除了基础的框架和 UI 库之外, 我们只需要加载当前页面的代码即可, 这就有得用到Code Splitting技术进行代码分割, 我们要做的其实很简单

## 组件加载

> 路由其实是一个大组件, 很多时候人们忽略了路由跳转之间的加载优化, 更多的时候我们的精力都留在首屏加载之上, 但是路由跳转间的加载同样重要, 如果加载过慢同样影响用户体验。

其他优化方案：

* 图片懒加载方案
* 资源压缩, 现在基本上用反向代理工具都是自动开启的
* cdn
* 雪碧图, 很古老的技术了, http2 使用后也是效果有限了
* css 放头, js 放最后, 这种方式适合工程化之前, 现在基本都用打包工具代替了
